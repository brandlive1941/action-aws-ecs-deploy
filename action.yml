name: 'action-aws-ecs-deploy'
description: 'Configures AWS, renders Task Definition, and deploys to ECS for a single service/region combination.'

inputs:
  task-definition:
    description: 'The task definition file path (e.g., .aws/sandbox-us-west-2-translation-service.json)'
    required: true
  container-name:
    description: 'The name of the container in the task definition to update (e.g., sandbox-translation-service-container)'
    required: true
  container_port:
    description: 'The port on the container to associate with the load balancer (e.g., 8080)'
    required: false # Making false to not break existing calls if any
    default: '80'
  region:
    description: 'The AWS region to deploy to'
    required: true
  service:
    description: 'The name of the service to deploy (e.g., translation-service)'
    required: true
  cluster:
    description: 'The name of the ECS cluster to deploy to (e.g., platform-sandbox-us-west-2)'
    required: true
  image:
    description: 'The ECR image URL (e.g., 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-image:latest)'
    required: true
  role:
    description: 'The IAM Role ARN to assume for deployment'
    required: true
  create_service:
    description: 'Set to true to create the service if it does not exist'
    required: false
    default: 'false'
  launch_type: 
    description: 'The launch type to use for the service, used only when creating a new service'
    required: false
    default: 'FARGATE'
  desired_count: 
    description: 'The desired count for the service, used only when creating a new service'
    required: false
    default: '0'
  subnets:
    description: 'The subnets to use for the service, used only when creating a new service'
    required: false
    default: '[]'
  security_groups:
    description: 'The security groups to use for the service, used only when creating a new service'
    required: false
    default: '[]' 
  target_group:
    description: 'The target group ARN to use for the service, used only when creating a new service'
    required: false
  environment:
    description: 'The environment name (e.g., sandbox, dev, qa)'
    required: false # Making false to not break existing calls, but needed for fetching config

runs:
  using: "composite"
  steps:
    - id: checkout_cod
      uses: actions/checkout@v5

    - id: job_info
      shell: bash
      run: |
        echo "Deploying to ${{ inputs.cluster }}"
        echo "Region ${{ inputs.region }}"
        echo "Service ${{ inputs.service }}"
        echo "Role ${{ inputs.role }}"
        echo "Image ${{ inputs.image }}"
        echo "Container Name ${{ inputs.container-name }}"

    - id: configure_aws_credentials
      uses: aws-actions/configure-aws-credentials@v3
      with:
        role-to-assume: ${{ inputs.role }}
        role-session-name: github-action-session-deploy
        aws-region: ${{ inputs.region }}

    - id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        # Construct the task definition path using inputs
        task-definition: ${{ inputs.task-definition }}
        # Construct the container name using inputs
        container-name: ${{ inputs.container-name }}
        # Construct the full image URL using inputs
        image: ${{ inputs.image }}

    - id: fetch-config
      if: ${{ inputs.create_service == 'true' }}
      shell: bash
      run: |
        # Fetch Subnets and Security Groups from SSM
        SUBNET_A=$(aws ssm get-parameter --name /SUBNET_A --query Parameter.Value --output text)
        SUBNET_B=$(aws ssm get-parameter --name /SUBNET_B --query Parameter.Value --output text)
        SUBNET_C=$(aws ssm get-parameter --name /SUBNET_C --query Parameter.Value --output text)
        echo "subnets=[$SUBNET_A,$SUBNET_B,$SUBNET_C]" >> $GITHUB_OUTPUT

        SECURITY_GROUP=$(aws ssm get-parameter --name /${{ inputs.environment }}/${{ inputs.container-name }}/SECURITY_GROUP --query Parameter.Value --output text)
        echo "security_groups=[$SECURITY_GROUP]" >> $GITHUB_OUTPUT

        # Fetch Target Group ARN from SSM
        TG_ARN=$(aws ssm get-parameter --name /${{ inputs.environment }}/${{ inputs.container-name }}/TG_ARN --query Parameter.Value --output text)
        echo "target_group=$TG_ARN" >> $GITHUB_OUTPUT

        # Extract Container Port
        # Using the output task definition from the previous step which is the rendered one
        CONTAINER_PORT=$(jq -r --arg CONTAINER "${{ inputs.container-name }}" '.containerDefinitions[] | select(.name == $CONTAINER) | .portMappings[0].containerPort' ${{ steps.task-def.outputs.task-definition }})
        # If extraction failed or empty (e.g. no port mappings), default to 80 or input default?
        # Inputs default is 80.
        if [ -z "$CONTAINER_PORT" ] || [ "$CONTAINER_PORT" == "null" ]; then
           CONTAINER_PORT="${{ inputs.container_port }}"
        fi
        echo "container_port=$CONTAINER_PORT" >> $GITHUB_OUTPUT

    - id: create_service
      if: ${{ inputs.create_service == 'true' }}
      shell: bash
      run: |
        TARGET_GROUP="${{ steps.fetch-config.outputs.target_group }}"
        CONTAINER_PORT="${{ steps.fetch-config.outputs.container_port }}"
        SUBNETS="${{ steps.fetch-config.outputs.subnets }}"
        SECURITY_GROUPS="${{ steps.fetch-config.outputs.security_groups }}"
        
        # Fallback to inputs if fetching failed or environment not provided (though subnets likely fail if env missing)
        if [ -z "$SUBNETS" ]; then SUBNETS="${{ inputs.subnets }}"; fi
        if [ -z "$SECURITY_GROUPS" ]; then SECURITY_GROUPS="${{ inputs.security_groups }}"; fi
        # If target group was not found dynamically, check input
        if [ -z "$TARGET_GROUP" ]; then TARGET_GROUP="${{ inputs.target_group }}"; fi

        if [ -z "$TARGET_GROUP" ] || [ "$TARGET_GROUP" == "[]" ]; then
          aws ecs create-service \
            --cluster ${{ inputs.cluster }} \
            --service-name ${{ inputs.service }} \
            --task-definition ${{ steps.task-def.outputs.task-definition }} \
            --desired-count ${{ inputs.desired_count }} \
            --launch-type ${{ inputs.launch_type }} \
            --network-configuration "awsvpcConfiguration={subnets=$SUBNETS,securityGroups=$SECURITY_GROUPS,assignPublicIp=DISABLED}"
        else
          aws ecs create-service \
            --cluster ${{ inputs.cluster }} \
            --service-name ${{ inputs.service }} \
            --task-definition ${{ steps.task-def.outputs.task-definition }} \
            --desired-count ${{ inputs.desired_count }} \
            --launch-type ${{ inputs.launch_type }} \
            --network-configuration "awsvpcConfiguration={subnets=$SUBNETS,securityGroups=$SECURITY_GROUPS,assignPublicIp=DISABLED}" \
            --load-balancers "targetGroupArn=$TARGET_GROUP,containerName=${{ inputs.container-name }},containerPort=$CONTAINER_PORT"
        fi
        ls -al ${{ steps.task-def.outputs.task-definition }}

    - id: deploy
      uses: aws-actions/amazon-ecs-deploy-task-definition@v2
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        # Construct the service name using inputs
        service: ${{ inputs.service }}
        # Construct the cluster name using inputs
        cluster: ${{ inputs.cluster }}
        wait-for-service-stability: true
